---
layout: post
title:  "C/C++ 基础总结"
date:   2020-07-24 06:00:00
categories: C/C++
tags: C/C++ 语言基础
mathjax: true
mermaid: true
---

* content
{:toc}

最近可能要参加不少笔试面试，找了些C/C++语言基础方面的材料，打算过一遍，这里记录总结一些自己有些模糊的概念。

#### const
* 修饰变量，指针，引用：被修饰的目标不可被修改。类的const常量仅能在初始化了列表赋值。
* 修饰成员函数：该成员函数不可修改成员变量的值。const 可用于对重载函数的区分，const的该类对象<span style="color:red">仅能调用const修饰成员函数重载</span>，非const的该类对象会优先匹配到没有const修饰的重载。
* const int* func(); 返回一个指向常量的指针变量。int* const func();返回一个指向变量的常指针，但是接受这个值的不一定是变量(类似于变量可以等于一个常量)。

#### static
* static修饰的普通变量，没有初始化，会自动默认值初始化。
* static修饰的普通函数(非成员函数)一定要包括写成员函数的文件(如果写在.cpp里，包括相应的.h并不能调用)才能调用。

#### this
* this本身被隐式声明为`ClassName const this;`

#### inline内联
* 相当于把内联函数的内容写到了函数调用处，不用执行进入函数的步骤。
* 编译器一般不内联循环、递归、switch等复杂的内联函数。
* 隐式内联：在声明处定义的函数，除了虚函数外都会自动成为内联函数。
* 虚函数可以内联，但虚函数表现多态(因为运行时才知道具体调用函数)是不可以内联。

#### volatile
* 声明变量是可能被一些未知因素给改变，所以不能对该对象进行优化。(例如用寄存器的值替代内存的值等)。

#### assert
* 是宏，不是函数。可在include之前使用#define NDEBUG来禁止使用assert断言。

#### sizeof
* 对数组是整个数组的空间大小，对指针是指针本身空间的大小。
  
#### 结构体、Union空间问题
* 结构体排列的变量大小有自动对齐排列的功能。每个字符加入去占有空间时，看上一个字符占用内存未知，再填充对齐到自己需要的位置。最后大小也要对齐到所包含变量类型最大长度的整数倍。
* Union也是对齐最大数据类型长度的整数倍。不过是不同数据公用同一块空间。包含一个13个char的数组和一个int型变量的union占用空间大小为16个字节。
* #pragma pack(n) 设置结构体、union和类成员变量对齐方式，n取值可取1,2,4,8和16。实际是取n和构造过程中对齐方式的最小值。
 ```cpp
 #pragma pack(push)
 #pragma pack(4)
 ```

 #### 位域
 * 在变量名称后加冒号`:n`，改变变量存储的大小，指定变量存储的位数(存变量的最小n个bit)。对存储大小，和取地址都有影响。普通变量(不是类的成员变量)不可声明位域。
```cpp
typedef unsigned int Bit; // 这里用无符号的int举例，也可以是其他有符号的类型，必须是整型或枚举类型
class MyClass1
{
public:
    // 数据存储的对齐方式，任按照Bit原始大小对齐，不过这里一共仅需4字节即可存储。
    // 指针无法指向类的位域，所以取地址运算对位域也不可用
	Bit mode : 3; // 仅存储变量的3位
	Bit mode1 : 2; // 仅存储变量的2位
}
```

#### extern
* extern修饰变量和函数，扩大其作用域，使其可以在其他源文件和头文件使用。
* extern"C"让编译器把代码当成C语言代码处理。