---
layout: post
title:  "计算机网络学习笔记五 运输层"
date:   2020-07-22 06:00:00
categories: 计算机网络
tags: 计算机网络 运输层
mathjax: true
mermaid: false
excerpt_separator: <!--more-->
---

* content
{:toc}

本篇主要包括运输层的相关介绍，运输层协议概述、UDP、TCP 和 TCP 传输的一些具体内容。
<!--more-->

## 运输层协议概述
### 进程之间的通信
* 传输层提供了主机应用程序进程之间端到端的服务。
* 只有位于网络边缘的主机的协议栈才由运输层，而中心部分的路由器转发分组只用到下三层。
* 网络层：为主机之间提供逻辑通信。运输层：为<font color = "red">应用进程之间</font>提供端到端的逻辑通信。
* 一台主机多个应用进程同时分别和另一台主机的多个应用进程通信。则涉及到<font color = "red">IP 复用和 IP 分用</font> 。
* 应用程序的不同需求，运输层有两种不同协议：<font color = "red">面向连接的 TCP 协议</font>和<font color = "red">无连接的 UDP 协议</font>。

### 运输层的两个主要协议
* 传送的数据单位均为：运输协议数据单元 TPDU，Transport Protocol Data Unit。
* 用户数据报协议 UDP，User Datagram Protocol
* 传输控制协议 TCP，Transmission Control Protocol
* UDP：传输数据<font color = "red">不需要建立连接</font>。传送的数据单位协议是<font color = "red">UDP 报文</font>。收到 UDP 报文后不需要给出任何确认，<font color = "red">不提供可靠交付</font>。
* TCP：面向连接的服务。传送的数据单位协议是<font color = "red">TCP 报文段（segment）</font>。因此<font color = "red">不提供多播和广播服务</font>。提供可靠、面向连接的运输服务，<font color = "red">增加开销</font>。

### 运输层的端口
* 计算机进程有进程标识符，但运行在应用层上的应用进程不应当由计算机操作系统指派进程标识符。
* 解决问题的方法是运输层使用协议端口号（protocol port number）, 简称<font color = "red">端口 port</font>。
* 端口号是一个 16 位数，<font color = "red">仅具有本地意义</font>，标注本计算机应用层的各进程。所以找到进程需要知道对方计算机的 IP 地址和对方进程的端口号。
* 端口号分为两大类：
  * 服务器端口：熟知端口，登记端口号（无熟知端口号对应的应用程序，所以使用需要登记放重复）。
  * 客户端使用的端口号：又称短暂端口号 49152 及以上。通信结束后归还端口号，其他进程可使用。

## 用户数据报协议UDP
### UDP概述
* UDP 只在 IP 数据报服务基础增加了很少的功能：复用和分用的功能，差错检测的功能。
* UDP 特点：
  * UDP 是<font color = "red">无连接的</font>。
  * UDP 使用尽最大努力交付；不保证可靠交付。
  * UDP 是面向报文的。
    * 对应用层交下来的报文既不合并也不拆分，保留报文边界，一次性交付完整报文。
    * 应用程序必须选择合适的报文长度，太长或太短都不利于 IP 层的效率（太长会 IP 层分片，太短 IP 层头部占比过大）。
  * UDP 没有拥塞控制，出现拥塞也不会降低源主机发送速率，对实时应用很重要。
  * UDP 支持一对一，一对多，多对一和多对多通信。
  * UDP 的首部开销小，仅需 8 字节。

### UDP的首部格式
* UDP 首部 8 字节包含：源端口，目的端口，长度，检验和。各 2 字节。
* UDP 基于端口的分用：运输层从 IP 层获得 UDP 数据，根据部首中的端口把 UDP 数据上交给最后终点应用程序。
* UDP 检验：把伪部首增加到 UDP 用户数据报前计算检验和。伪部首部分 12 字节：源 IP(4 字节)，目的 IP(4 字节)，0(1 字节)，17(1 字节，IP 数据报首部中协议字段的值，UDP 所以是 17)，UDP 用户数据报长度（2 字节，包括 UDP 首部长度+UDP 数据长度）。另外 UDP 数据报最后要补全 4 字节的整数倍（补全的 0 不计入 UDP 用户数据报长度）。
* 检验方法是<font color = "red">二进制反码运算求和</font>，具体步骤如下：
  1. 每两个字节一个数，求反码；(计算检验和字段时，检验和字段看成 0)
  2. 反码相加，相加结果最高位如果进位，则在结果最低位加 1。
  3. 计算检验和字段：所有数字按照 1-2 步骤相加得到结果，填入检验和字段位置。
  4. 检验和字段检验：添加伪首部，添加补全 0，按照步骤 1-2 计算所有数字和，数字和全为 1 则通过，不是则丢弃。

## 传输控制协议TCP概述
### TCP 主要特点：
* TCP 面向连接：每条 TCP 连接只能由两个端点，只能是点对点的。
* TCP 提供可靠交付的服务。
* TCP 提供全双工通信。
* 面向字节流：
  * “流”（stream）指的是流入或流出进程的字节序列；
  * “面向字节流”：进程和 TCP 交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成一串无结构的字节流。
  * TCP 接受放应用程序收到的字节流必须和发送放应用程序发出的字节流<font color = "red">完全一样</font>。
  * TCP 不关心应用进程一次把多长的报文发送给 TCP 缓存。TCP 对连续的字节流分段，形成 TCP 报文段。
  * TCP 根据<font color = "red">窗口值</font>和<font color = "red">当前网络的阻塞</font>决定一个报文的字节数。(UDP 的报文长度则由<font color = "red">应用进程</font>决定)
  * 所以 TCP 可以划分数据报发送，也可以积累足够字节后发送。

### TCP的连接
* TCP 连接的端点叫做套接字（Socket）或插口。<font color = "red">端口号拼接到 IP 地址即构成了套接字</font>，套接字 $socket = (IP 地址：端口)$，$TCP 连接：:={socket1, socket2}={(IP1:port1), (IP2:ports)}$。

## 可靠传输的工作原理
* 理想的传输条件具有两个特点：
  * 传输信道不产生差错。
  * 无论多快的发送速度，接收方总来得及处理。

### 停止等待协议
* 无差错情况：“停止等待”指每发送完一个分组就停止发送，等待对方确认，确认后发送下一个分组。
* 出现差错分：为两种情况：
  * 情况一：接收到分组数据报，但检测出差错，丢弃，但接收方其他什么都不做。
  * 情况二：接收方没有收到数据。
  * 解决方案：<font color = "red">超时重传</font>，每个分组设置计时器，超时没收到则重发。
* 确认丢失和确认迟到：
  * 发送方收到重复确认，丢弃，不处理。
  * 接收方收到重复数据报，也丢弃，<font color = "red">但重新传送确认分组</font>。
* 按照上述传输方式的可靠传输协议通常称为<font color = "red">自动重传请求 ARQ, Automatic Repeat reQuest</font>。重传请求是自动进行的，接收方不需要请求发送重传。
* <font color = "red">信道利用率 $U$</font>：$T_D$ 发送分组的发送时延，$RTT$ 往返传播时延， $T_A$ 确认消息的发送时延
  
  <div class = "post-container">
  $$
  U = \frac{T_D}{T_D+RTT+T_A}
  $$
  </div>

* 为提高效率，采用了流水线传输：发送方不必发完每个分组都等待确认，连续发送多个分组。一直有数据传输，所以提高了信道利用率。

### 连续ARQ协议
* 发送方维持<font color="red">发送窗口</font>：位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。
* 连续 ARQ 协议规定，发送方每收到一个确认，窗口向前滑动一个分组的位置。
* 接收方采用<font color = "red">积累确认</font>方式。不逐个分组发送确认，对按序到达的最后一个分组发送确认，表示所有分组已收到。优点：容易实现，丢失不必重传。缺点：不能反映接收方已经正确收到的分组信息。
* <font color="red">Go-back-N</font>:表示退回重传已发送过的 N 个分组（即使 N 个分组中的后几个分组正确传送了）。因此当通信线路质量不好时，连续 ARQ 协议带来负面影响。

## TCP报文段的首部格式
* TCP 报文首部：20 个字节的固定首部和 4n 个根据需要增加的选项（$n \in N$）。具体如图所示：

<figure align="center">
  <img src = "/media/image/ComputerNetwork/TCPComposition.png" style="width:80%" />
</figure>

* <span style="color:red;">端口字段</span>：总共 4 字节，运输层与应用层的服务接口，运输层的复用和分用功能通过端口得以实现。
* <span style="color:red;">序号字段 seq</span>：4 字节，指本报文所发第一个字节的在数据流中的序号。32 位长度表示。
* <span style="color:red;">确认号字段 ack</span>：4 字节，期望对方下一个报文段的数据第一个字节的序号。(这是根据己方之前正确接收数据的最大序号+1，4 个字节则有 4GB 的数据，所以一般重复利用时，老序号数据早已到达终点)
* 数据偏移字段：1 个字节，指出 TCP 报文段中，TCP 首部长度（TCP 数据部分开头相对于 TCP 报文段开头的偏移量）。1 个字节所以也会影响到选项长度。
* <span style="color:red;">窗口字段</span>：2 字节，让对方设置发送窗口的依据。(往往根据己方接受窗口大小/数据缓存空间有关)
* <span style="color:red;">检验和字段</span>：2 字节，检验和字段检验范围包括首部和数据两部分。计算是应该添加 TCP 报文段的前面 12 字节的伪首部（与 UDP 相似，但第四个字段协议号是 TCP 协议号 6，第五个字段是 TCP 长度）。使用 IPv6 时相应的伪首部也要变化。
* 另外有六个控制位说明报文段的性质：紧急 URG(配合紧急指针使用)，确认 ACK(链接建立后，为 1),推送 PSH，复位 RST(一般由于出错，或拒绝会使用，用于释放重连)，同步 SYN(配合 ACK 用于建立连接)，终止 FIN(释放连接)。
* 选项：最长 40 字节。由 $(2^4 - 1)*4$ 个 4 字节长度决定，除去固定首部得到 40 字节。

## TCP可靠传输的实现
### 以字节为单位的滑动窗口
* 字节为单位的滑动窗口，与发送方接受方的缓存量有关，和读取写入速度有关，与网络质量也有关。
* 注意的问题：
  * 发送窗口是根据对方的接受窗口设定，但由于网络有滞后性，所以两者窗口并不是一样大，发送方可能要根据网络拥塞情况适当减小自己的发送窗口。
  * 不按需到达的数据，TCP 协议并无明确规定。但均丢弃对网络资源利用不利。大多数情况 TCP 会临时存放，等缺少的字符收到后，再<font color = "red">按序上交</font>。
  * TCP 要求接受方<font color = "red">一定要有累积确认功能</font>。不应过分推迟，规定推迟确认时间不超过 0.5s.捎带确认信息的 TCP 数据报并不常见，因为"全双工工作"的状态不常见。

### 超时重传时间的选择
* 重传时间的选择时 TCP 最复杂的问题之一。受互联网环境影响，运输层往返时间（RTT）方差很大。
* TCP 采用自适应算法计算往返时间 RTT 的加权平均往返时间 $RTT_s$(又称平滑的往返时间)。
* 加权平均往返时间 $RTT_S$ 计算公式（除第一次，直接去样本值）。其中 RFC2988 推荐 $\alpha$ 取 0.125。
  <div class = "post-container">
  $$
  RTT_S = (1-\alpha) \times RTT_s + \alpha \times 新样本 RTT
  $$
  </div>
* Karn 算法：报文重传则计入往返时间 RTT 的样本。
* 修正的 Karn 算法：报文重传一次，则重算一次 RTT，$RTT = \gamma \times RTT$, $\gamma$ 典型值为 2。不发生重传时，才正常跟新加权平均往返时间。

### 选择确认SACk
* 未按序号接受的正确数据，是否可确认：可以，解决方案：<font color = "red">选择确认 SACK</font> Selective ACK。
* 在 TCP 首部中选项部分，指明 SACK 选项（1 字节）和 SACK 选项长度（1 字节）, 每段以确定数据的（上下边界， 8 字节），所以最多能指明 4 个已确认的为按序号字节快。
* RFC 2018 要求在<span style="color:red;">建立 TCP 连接</span>时，应该在首部选项中加上“允许 SACK”选项，事先商量好。

## TCP的流量控制
### 利用滑动窗口实现流量控制
* 流量控制 flow control：让发送放的发送速率不要太快，既要让接收方来得及接受，同时也不要使网络发生拥塞。
* 滑动窗口控制流量的情况：接受方可通知发送发的 ACK 位置，并告知可对方可设置的滑动窗口大小。
* 持续计时器：解决互相等待死锁
  * <span style = "color:red">互相等待死锁</span>：接收方通知了发送方零窗口报文段。当接收方重新获得储存空间，增加发送方发送窗口，但这个报文段在传输过程丢失，出现发送方和接收方都持续等待的局面。
  * TCP 连接的一方接收到对方<span style="color:blue">零窗口</span>通知后，启动<span style="color:red">持续计时器</span>。计时器时间到，发送<span style="color:red">零窗口探测报文</span>(仅 1 个字节)，当窗口不是 0 时则打破死锁僵局。

### 必须考虑传输效率
* TCP 报文段发送机制：
  * <span style="color:red">MSS 机制</span>：TCP 维持一个变量，它等于最大报文段长度 MSS, Maximum Segment Size 时再组装成一个 TCP 报文发送。MSS 值时在建立 TCP 连接时通知号对方的（TCP 首部选项）。
  * <span style="color:red">推送机制</span>：发送方的应用进程明确要求发送报文段（要求该 TCP 连接支持推送操作）。
  * <span style="color:red">计时器机制</span>：计时器时间到则把当前已有缓冲装入报文段发送。
* 发送方短数据问题：发送方每次发送非常小的数据量（1 个字节），接收方收到则给与 40 字节确认报文。导致 TCP，IP 首部占整个收发数据报的绝大部分。
  * <span style="color:red">Nagle 算法</span>：如果发送应用进程把要发送的数据逐个字节送到 TCP 缓存，发送方先发送第一个数据字节，后面缓存，等待收到确认后再把缓冲数据一起发送。后续<span style="color:blue">只有在接收到前一个报文段的确认后才继续发送下一个报文段</span>。另外规定，当数据到<span style="color:red">达发送窗口大小的一半</span>或<span style="color:red">已达到报文段的最大长度</span>则立即发送。
* 糊涂窗口综合征：接收方应用进程每次仅读取 1 个字节，导致接收方窗口大小为 1 字节，则邀请发送方发送一个字节数据，于是接收方窗口又满了。如此循环往复。
  * 解决方案：仅有两种情况接收方发出确认报文，并通知发送方窗口大小：
  * 接收缓存足够容纳最长的报文段；
  * 接受缓存已有一半空闲空间。

## TCP的拥塞控制
### 拥塞控制的一般原理
* 拥塞：$\sum 资源需求 > 可用资源 $
* 往往单纯增加资源（例如增加缓存）不能很好的解决拥塞。所以需要拥塞控制：防止过多数据注入到网络中，使路由器或链路不致过载。
* 拥塞控制于流量控制的区别与相似：
  * 拥塞控制：全局性过程，涉及到所有主机、路由器和降低网络传输性能的所有因素。
  * 流量控制：点到点的流量控制，是一个端到端问题。要做的是抑制发送方发送数据的速率使得接收方来得及接受。
  * 相似点：某些拥塞算法需要对发送端发送控制报文，告诉发送端放慢发送速率。
* 开环控制：在设计网络时，实现考虑拥塞影响因素，力求工作时不拥塞。
* 闭环控制：基于反馈环路的概念：
  * 监测网络，检测拥塞发生时间、地点；
  * 将拥塞信息发送给采取行动的地方；
  * 调整网络运行以解决问题。
* 监测网络拥塞的指标：<span style="color:red">缺少缓存而丢弃的分组百分数，平均队列长度，超时重传的分组数，平均分组时延，分组时延的标准差等</span>。上诉指标上升，则拥塞增长。

### 拥塞控制方法
* 基于窗口的方法-拥塞窗口 CWND
  * TCP 发送方维持拥塞窗口 CWND，Congestion Window：取决于网络拥塞程度动态变化，利用拥塞窗口调整发送数据量。单位是<span style="color:red">报文段数目，这里仅是示例，不一定真实情况</span>。
  * $ 真正的发送窗口 = Min(公告窗口值，拥塞窗口值)$ 
  * 基本原则：没用拥塞增大窗口，出现拥塞或可能拥塞，减小窗口。
  * 如何判断拥塞：重传定时器：出现超时则可猜想网络出现拥塞（传输错误概率很小）；接受三个相同的 ACK(预示<span style="color:red">可能</span>发生拥塞)。
* 控制拥塞的四种算法（实际时配合使用的）：
  * 慢开始：cwnd 从 1 开始增加，经过一个传输轮次（cwnd 数目的报文段收到了确认），cwnd 翻倍。慢开始门限 ssthresh：cwnd 数目超过门限值后，进入拥塞避免算法。
  * 拥塞避免：cwnd 窗口每个传输轮次，按照线性增加。
  * 快重传：超时重传则减小慢开始门限值 ssthresh(<span style = "color:red">乘法减小</span>：减小为当前 cwnd 的一半)，并 cwnd 设置为 1，重新慢开始算法。
  * 快恢复：收到三个重复确认（接收方收到失序报文，立即发送重复确认），<span style = "color:red">立即重传</span>确认位置之后的报文段（<span style = "color:red">不必等待该报文段重传计时</span>）。同时 ssthresh 乘法减小，cwnd 设置为减小后的 ssthresh，进入拥塞避免算法。

<figure align="center">
  <img src = "/media/image/ComputerNetwork/CongestionControlAlgo.png" style="width:80%" />
</figure>

* 随机早期检测 RED：不免全局同步，随机早期检测 RED, Random Early Detecion (Random Early Drop)。<span style="color:blue">加权平均队列长度</span>，<span style="color:blue">超过最小门限，小于最大门限</span>时，按照<span style="color:blue">一定概率计算方式</span>将新到达的分组丢弃。丢弃概率与加权平均队列长度和新到达分组已进入队列数目有关。

## TCP的运输连接管理
* TCP 运输连接三阶段：<span style="color:red">连接建立， 数据传送， 连接释放</span>
* 运输连接的管理：就是使得运输连接的建立和释放都能正常进行。
* TCP 连接建立过程解决三个问题：
  * 双方知道对方存在；
  * 能够协商一些参数（最大窗口值，是否使用窗口扩大选项，时间戳选项、以及服务质量等）。
  * 能够对运输实体资源（缓存大小，连接表中的项目等）进行分配。
* 客户-服务器方式：发起连接的应用进程叫<span style="color:red">客户</span>，等待连接建立的应用进程叫<span style="color:red">服务器</span>。

### TCP的连接建立
* TCP 建立连接的过程叫做<span style="color:red">握手</span>。
* 客户和服务器之间交换三个 TCP 报文，称之为<span style="color:red">三报文握手</span>。具体流程如下图：
<figure align="center">
  <img src = "/media/image/ComputerNetwork/TCPEstablish.png" style="width:80%" />
</figure>

* 注意：
  * 第一次报文，客户端进程发送数据报<span style="color:red">不带数据但消耗一个序号</span>。进入<span style="color:blue">SYN-SENT</span>状态。
  * 第二次报文，服务器端进程发发送数据报<span style="color:red">不带数据但消耗一个序号</span>。进入<span style="color:blue">SYN-RCVD</span>状态。
  * 第三次报文，客户端进程<span style="color:red">可携带数据</span>，携带则消耗序号，不携带则不消耗。客户端进入<span style="color:blue">ESTABLISHED</span>状态，服务器端接收到第三次握手数据报时，也进入 ESTABLISHED 状态。
  * 第三次报文是为了防止已失效的连接请求报文突然又传到产生错误。

### TCP连接释放
* TCP 连接释放过程：四报文握手。
* 客户和服务器之间进行四个报文交换完成四报文握手。具体流程如下图所示：
<figure align="center">
  <img src = "/media/image/ComputerNetwork/TCPRelease.png" style="width:80%" />
</figure>

* 注意：
  * 发送连接释放报文段（无论是主动方，还是被动方）, 不携带数据，FIN= 1, 并消耗一个序号。
  * 主动关闭方完成前两次握手后， 任然要接受数据， 处于半关闭状态。
  * 主动方发出最后一次确认后， 开启时间等待（TIME-WAIT）状态， 时间等待计时器计时，等待 2MSL 最长报文段寿命（Maximum Segment Lifetime）.作用： 1. 保证被动关闭方接受到最后关闭确认退出 LAST-ACK 状态。 2. 保证网络中本次连接的所有报文段从网络中小时。
